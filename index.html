<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Number Sums</title>
  
  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Number Sums">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  
  <!-- SEO -->
  <meta name="description" content="Êï∞Â≠ó„ÇíÈÅ∏„Çì„ÅßÂêàË®à„ÇíÁõÆÊ®ôÂÄ§„Å´Âêà„Çè„Åõ„Çã„Éë„Ç∫„É´„Ç≤„Éº„É†„ÄÇ2500Âïè„ÅÆÂõ∫ÂÆö„Éë„Ç∫„É´„Å´ÊåëÊà¶ÔºÅ">
  <meta name="keywords" content="„Éë„Ç∫„É´,Êï∞Â≠ó,„Ç≤„Éº„É†,ËÑ≥„Éà„É¨,Number Sums">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    :root {
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9ff;
      --bg-tertiary: #f5f5f5;
      --bg-card: #ffffff;
      --text-primary: #333333;
      --text-secondary: #666666;
      --text-tertiary: #888888;
      --border-color: #eeeeee;
      --border-dark: #e0e0e0;
      --accent-color: #5c6bc0;
      --accent-light: #f0f0ff;
      --success-color: #4caf50;
      --error-color: #e53935;
      --warning-color: #f57c00;
      --gradient-start: #667eea;
      --gradient-end: #764ba2;
      --shadow-color: rgba(0,0,0,0.1);
      --overlay-bg: rgba(0,0,0,0.6);
    }
    
    [data-theme="dark"] {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --bg-card: #1a1a2e;
      --text-primary: #eaeaea;
      --text-secondary: #b0b0b0;
      --text-tertiary: #808080;
      --border-color: #2a2a4a;
      --border-dark: #3a3a5a;
      --accent-color: #7c8ce0;
      --accent-light: #2a2a4a;
      --shadow-color: rgba(0,0,0,0.3);
      --overlay-bg: rgba(0,0,0,0.8);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
      min-height: 100vh;
      touch-action: manipulation;
      transition: background 0.3s;
    }
    .app {
      min-height: 100vh;
      max-width: 500px;
      margin: 0 auto;
      background: var(--bg-primary);
      position: relative;
      transition: background 0.3s;
    }
    
    /* „Éõ„Éº„É†ÁîªÈù¢ */
    .home-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px 20px;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
    }
    .home-logo { font-size: 48px; margin-bottom: 8px; }
    .home-title { font-size: 32px; font-weight: 800; color: var(--text-primary); margin-bottom: 8px; }
    .home-subtitle { font-size: 14px; color: var(--text-tertiary); margin-bottom: 40px; }
    .home-btn {
      width: 100%; max-width: 280px; padding: 16px 24px; border-radius: 16px;
      font-size: 18px; font-weight: 700; border: none; cursor: pointer;
      transition: all 0.2s; margin-bottom: 12px;
    }
    .home-btn:active { transform: scale(0.98); }
    .home-btn.primary {
      background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
      color: white; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    .home-btn.secondary { background: var(--bg-tertiary); color: var(--text-primary); }
    .home-btn.settings { background: transparent; color: var(--text-secondary); font-size: 14px; padding: 12px; }
    .home-stats { margin-top: 40px; display: flex; gap: 24px; }
    .stat-item { text-align: center; }
    .stat-value { font-size: 28px; font-weight: 700; color: var(--accent-color); }
    .stat-label { font-size: 12px; color: var(--text-tertiary); }
    .lives-display { margin-top: 32px; text-align: center; }
    .lives-hearts { font-size: 32px; letter-spacing: 4px; }
    .lives-timer { font-size: 13px; color: var(--text-tertiary); margin-top: 8px; }
    .lives-full { font-size: 13px; color: var(--success-color); margin-top: 8px; }
    
    /* Ë®≠ÂÆöÁîªÈù¢ */
    .settings-screen { min-height: 100vh; background: var(--bg-secondary); }
    .settings-header {
      padding: 16px; background: var(--bg-card); display: flex;
      align-items: center; gap: 12px; border-bottom: 1px solid var(--border-color);
    }
    .settings-title { font-size: 18px; font-weight: 700; color: var(--text-primary); }
    .settings-list { padding: 16px; }
    .settings-item {
      display: flex; justify-content: space-between; align-items: center;
      padding: 16px; background: var(--bg-card); border-radius: 12px; margin-bottom: 8px;
    }
    .settings-item-label { font-size: 16px; color: var(--text-primary); }
    .settings-item-desc { font-size: 12px; color: var(--text-tertiary); margin-top: 4px; }
    .toggle {
      width: 52px; height: 28px; background: var(--bg-tertiary); border-radius: 14px;
      position: relative; cursor: pointer; transition: background 0.3s;
    }
    .toggle.active { background: var(--accent-color); }
    .toggle::after {
      content: ''; position: absolute; width: 24px; height: 24px; background: white;
      border-radius: 50%; top: 2px; left: 2px; transition: transform 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .toggle.active::after { transform: translateX(24px); }
    
    /* ÂïèÈ°åÈÅ∏ÊäûÁîªÈù¢ */
    .select-screen { min-height: 100vh; display: flex; flex-direction: column; background: var(--bg-secondary); }
    .select-header {
      padding: 16px; background: var(--bg-card); display: flex;
      align-items: center; gap: 12px; border-bottom: 1px solid var(--border-color);
    }
    .back-btn {
      width: 40px; height: 40px; border-radius: 12px; border: none;
      background: var(--bg-tertiary); font-size: 20px; cursor: pointer;
      display: flex; align-items: center; justify-content: center; color: var(--text-primary);
    }
    .select-title { font-size: 18px; font-weight: 700; flex: 1; color: var(--text-primary); }
    .diff-tabs { display: flex; padding: 12px 16px; gap: 8px; background: var(--bg-card); }
    .diff-tab {
      flex: 1; padding: 12px; border-radius: 12px; border: 2px solid var(--border-color);
      background: var(--bg-card); font-size: 14px; font-weight: 600;
      cursor: pointer; text-align: center; transition: all 0.2s; color: var(--text-primary);
    }
    .diff-tab.active { border-color: var(--accent-color); background: var(--accent-light); color: var(--accent-color); }
    .diff-tab .count { font-size: 11px; color: var(--text-tertiary); margin-top: 2px; }
    .diff-tab.active .count { color: var(--accent-color); }
    .problem-grid {
      flex: 1; padding: 16px; display: grid; grid-template-columns: repeat(5, 1fr);
      gap: 10px; overflow-y: auto; align-content: start;
    }
    .problem-btn {
      aspect-ratio: 1; border-radius: 12px; border: 2px solid var(--border-dark);
      background: var(--bg-card); font-size: 16px; font-weight: 700; color: var(--text-primary);
      cursor: pointer; display: flex; flex-direction: column;
      align-items: center; justify-content: center; transition: all 0.2s;
    }
    .problem-btn:active { transform: scale(0.95); }
    .problem-btn.cleared { background: #e8f5e9; border-color: var(--success-color); color: var(--success-color); }
    [data-theme="dark"] .problem-btn.cleared { background: #1b3d2f; }
    .problem-btn.cleared .stars { font-size: 8px; margin-top: 2px; }
    
    /* „Ç≤„Éº„É†ÁîªÈù¢ */
    .game-screen { min-height: 100vh; display: flex; flex-direction: column; background: var(--bg-primary); }
    .game-header {
      padding: 12px 16px; display: flex; align-items: center;
      justify-content: space-between; border-bottom: 1px solid var(--border-color);
    }
    .game-info { display: flex; align-items: center; gap: 8px; }
    .problem-number { font-size: 16px; font-weight: 700; color: var(--text-primary); }
    .game-timer { font-size: 14px; color: var(--text-tertiary); font-variant-numeric: tabular-nums; }
    .game-lives { font-size: 20px; }
    .game-main { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 12px 8px; gap: 12px; }
    
    /* „Éú„Éº„Éâ */
    .board-container { display: flex; flex-direction: column; gap: 2px; }
    .col-sums { display: flex; margin-left: 44px; }
    .sum-box {
      width: 44px; height: 32px; display: flex; align-items: center; justify-content: center;
      font-size: 15px; font-weight: 700; color: var(--text-primary); position: relative;
    }
    .sum-box.complete { color: var(--text-tertiary); text-decoration: line-through; }
    .sum-box.over { color: var(--error-color); }
    .sum-box .current { position: absolute; top: -2px; right: 1px; font-size: 9px; font-weight: 600; color: var(--text-tertiary); }
    .sum-box.complete .current { display: none; }
    .board-row { display: flex; gap: 2px; }
    .row-sums { display: flex; flex-direction: column; }
    .row-sum-box {
      width: 42px; height: 44px; display: flex; align-items: center; justify-content: center;
      font-size: 15px; font-weight: 700; color: var(--text-primary); position: relative;
    }
    .row-sum-box.complete { color: var(--text-tertiary); text-decoration: line-through; }
    .row-sum-box.over { color: var(--error-color); }
    .row-sum-box .current { position: absolute; top: 2px; right: 1px; font-size: 9px; font-weight: 600; color: var(--text-tertiary); }
    .row-sum-box.complete .current { display: none; }
    .grid { display: grid; border: 1px solid var(--border-dark); border-radius: 4px; overflow: hidden; }
    .cell {
      width: 44px; height: 44px; display: flex; align-items: center; justify-content: center;
      font-size: 20px; font-weight: 700; cursor: pointer; position: relative;
      border-right: 1px solid var(--border-dark); border-bottom: 1px solid var(--border-dark);
      -webkit-tap-highlight-color: transparent; transition: background-color 0.2s; color: var(--text-primary);
    }
    .cell:active { opacity: 0.7; }
    .cell .cage-hint {
      position: absolute; top: 1px; left: 2px; font-size: 9px; font-weight: 700;
      color: var(--text-primary); background: rgba(255,255,255,0.85);
      padding: 0 3px; border-radius: 3px; line-height: 1.2; z-index: 10;
    }
    [data-theme="dark"] .cell .cage-hint { background: rgba(26,26,46,0.85); }
    .cell .cage-hint.complete { color: var(--success-color); text-decoration: line-through; }
    .cell .cage-hint.over { color: var(--error-color); }
    .cell.selected .number {
      display: flex; align-items: center; justify-content: center;
      width: 34px; height: 34px; border: 2.5px solid var(--text-primary);
      border-radius: 50%; background: rgba(255,255,255,0.5);
    }
    [data-theme="dark"] .cell.selected .number { background: rgba(255,255,255,0.1); }
    .cell.erased .number { visibility: hidden; }
    .cell.cage-resolved { background-color: var(--bg-primary) !important; }
    .cell.hinted { animation: hintPulse 0.5s ease-out; }
    .cell.wrong { animation: shake 0.4s; }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-4px); } 40%, 80% { transform: translateX(4px); } }
    @keyframes hintPulse { 0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); } 50% { box-shadow: 0 0 0 8px rgba(76, 175, 80, 0); } 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); } }
    
    .controls { width: 100%; max-width: 340px; padding: 12px; }
    .mode-switch { display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 12px; }
    .mode-btn {
      display: flex; flex-direction: column; align-items: center; gap: 4px;
      padding: 10px 20px; border-radius: 12px; border: 2px solid var(--border-color);
      background: var(--bg-card); cursor: pointer; transition: all 0.2s;
    }
    .mode-btn.active { border-color: var(--accent-color); background: var(--accent-light); }
    .mode-btn .icon { font-size: 18px; }
    .mode-btn .label { font-size: 11px; font-weight: 600; color: var(--text-secondary); }
    .mode-btn.active .label { color: var(--accent-color); }
    .game-actions { display: flex; gap: 8px; }
    .action-btn {
      flex: 1; padding: 12px; border-radius: 12px; border: none;
      font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;
    }
    .action-btn.hint { background: #fff3e0; color: var(--warning-color); }
    [data-theme="dark"] .action-btn.hint { background: #3d2e1a; }
    .action-btn.hint:disabled { opacity: 0.5; cursor: not-allowed; }
    .action-btn.reset { background: var(--bg-tertiary); color: var(--text-secondary); }
    
    /* „É¢„Éº„ÉÄ„É´ */
    .overlay {
      position: fixed; inset: 0; background: var(--overlay-bg);
      display: flex; align-items: center; justify-content: center; z-index: 100; animation: fadeIn 0.3s;
    }
    .modal {
      background: var(--bg-card); border-radius: 24px; padding: 32px; text-align: center;
      box-shadow: 0 20px 40px var(--shadow-color); animation: bounceIn 0.5s; max-width: 320px; width: 90%;
    }
    .modal-emoji { font-size: 56px; margin-bottom: 12px; }
    .modal-title { font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px; }
    .modal-title.gameover { color: var(--error-color); }
    .modal-stars { font-size: 32px; margin-bottom: 8px; }
    .modal-stats { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; }
    .modal-stat { text-align: center; }
    .modal-stat-value { font-size: 20px; font-weight: 700; color: var(--accent-color); }
    .modal-stat-label { font-size: 11px; color: var(--text-tertiary); }
    .modal-btn {
      width: 100%; padding: 14px;
      background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
      color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600;
      cursor: pointer; margin-bottom: 8px;
    }
    .modal-btn.secondary { background: var(--bg-tertiary); color: var(--text-primary); }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes bounceIn { 0% { transform: scale(0.3); opacity: 0; } 50% { transform: scale(1.05); } 70% { transform: scale(0.9); } 100% { transform: scale(1); opacity: 1; } }
    
    .loading { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; gap: 16px; }
    .loading-spinner { width: 40px; height: 40px; border: 4px solid var(--bg-tertiary); border-top-color: var(--accent-color); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { color: var(--text-secondary); font-size: 14px; }
    
    @media (max-width: 380px) {
      .cell { width: 38px; height: 38px; font-size: 17px; }
      .cell.selected .number { width: 28px; height: 28px; }
      .sum-box { width: 38px; height: 28px; font-size: 13px; }
      .row-sum-box { width: 36px; height: 38px; font-size: 13px; }
      .col-sums { margin-left: 38px; }
      .cell .cage-hint { font-size: 8px; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, useRef } = React;

    const PASTEL_COLORS = ['#FFCDD2', '#B3E5FC', '#C8E6C9', '#FFE0B2', '#E1BEE7', '#FFF9C4', '#B2EBF2', '#F8BBD0', '#DCEDC8', '#D7CCC8', '#CFD8DC', '#F0F4C3'];
    const PASTEL_COLORS_DARK = ['#4a2c2c', '#1e3a4a', '#2c3d2c', '#4a3c2c', '#3a2c4a', '#4a4a2c', '#2c4a4a', '#4a2c3a', '#3a4a2c', '#3a3432', '#2f3438', '#3a3c2c'];
    const DIFFICULTIES = { easy: { size: 7, selectRatio: 0.5, label: 'Á∞°Âçò', problems: 500 }, medium: { size: 8, selectRatio: 0.45, label: 'ÊôÆÈÄö', problems: 1000 }, hard: { size: 9, selectRatio: 0.4, label: 'Èõ£„Åó„ÅÑ', problems: 1000 } };
    const MAX_LIVES = 5, LIFE_RECOVERY_MINUTES = 30, MIN_CAGE_SIZE = 6, GAME_LIVES = 2, MAX_HINTS = 3;

    // „Çµ„Ç¶„É≥„ÉâÁÆ°ÁêÜ
    class SoundManager {
      constructor() { this.ctx = null; this.enabled = true; }
      init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
      }
      play(type) {
        if (!this.enabled) return;
        this.init();
        const ctx = this.ctx, now = ctx.currentTime;
        const osc = ctx.createOscillator(), gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        
        if (type === 'select') { osc.frequency.value = 600; osc.type = 'sine'; gain.gain.setValueAtTime(0.1, now); osc.start(now); osc.stop(now + 0.1); }
        else if (type === 'erase') { osc.frequency.value = 400; osc.type = 'sine'; gain.gain.setValueAtTime(0.08, now); osc.start(now); osc.stop(now + 0.08); }
        else if (type === 'wrong') { osc.frequency.setValueAtTime(200, now); osc.frequency.setValueAtTime(150, now + 0.1); osc.type = 'square'; gain.gain.setValueAtTime(0.15, now); gain.gain.setValueAtTime(0, now + 0.25); osc.start(now); osc.stop(now + 0.25); }
        else if (type === 'hint') { osc.frequency.setValueAtTime(800, now); osc.frequency.setValueAtTime(1000, now + 0.05); osc.type = 'sine'; gain.gain.setValueAtTime(0.1, now); gain.gain.setValueAtTime(0, now + 0.15); osc.start(now); osc.stop(now + 0.15); }
        else if (type === 'clear') { [523, 659, 784, 1047].forEach((f, i) => { const o = ctx.createOscillator(), g = ctx.createGain(); o.connect(g); g.connect(ctx.destination); o.frequency.value = f; o.type = 'sine'; g.gain.setValueAtTime(0.12, now + i * 0.15); g.gain.setValueAtTime(0, now + i * 0.15 + 0.2); o.start(now + i * 0.15); o.stop(now + i * 0.15 + 0.2); }); return; }
        else if (type === 'gameover') { osc.frequency.setValueAtTime(400, now); osc.frequency.setValueAtTime(200, now + 0.3); osc.type = 'sawtooth'; gain.gain.setValueAtTime(0.1, now); gain.gain.setValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); }
      }
    }
    const soundManager = new SoundManager();

    function mulberry32(seed) { return function() { let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
    function loadProgress() { try { const d = localStorage.getItem('numberSumsProgress'); return d ? JSON.parse(d) : { easy: {}, medium: {}, hard: {} }; } catch { return { easy: {}, medium: {}, hard: {} }; } }
    function saveProgress(p) { try { localStorage.setItem('numberSumsProgress', JSON.stringify(p)); } catch {} }
    function loadLives() { try { const d = localStorage.getItem('numberSumsLives'); if (d) { const p = JSON.parse(d), now = Date.now(), elapsed = now - p.lastUpdate, recovered = Math.floor(elapsed / (LIFE_RECOVERY_MINUTES * 60 * 1000)), newLives = Math.min(MAX_LIVES, p.current + recovered); return { current: newLives, lastUpdate: newLives >= MAX_LIVES ? now : p.lastUpdate + recovered * LIFE_RECOVERY_MINUTES * 60 * 1000 }; } } catch {} return { current: MAX_LIVES, lastUpdate: Date.now() }; }
    function saveLives(l) { try { localStorage.setItem('numberSumsLives', JSON.stringify(l)); } catch {} }
    function loadSettings() { try { const d = localStorage.getItem('numberSumsSettings'); return d ? JSON.parse(d) : { sound: true, darkMode: false }; } catch { return { sound: true, darkMode: false }; } }
    function saveSettings(s) { try { localStorage.setItem('numberSumsSettings', JSON.stringify(s)); } catch {} }

    function generateCagesSeeded(size, random) {
      const totalCells = size * size, cageCount = size, baseCageSize = Math.floor(totalCells / cageCount);
      let cages = null, attempts = 0;
      while (attempts++ < 50) {
        cages = tryGenCages(size, cageCount, baseCageSize, random);
        if (cages && cages.every(c => c.length >= MIN_CAGE_SIZE)) break;
      }
      if (!cages || !cages.every(c => c.length >= MIN_CAGE_SIZE)) cages = mergeCages(cages);
      return cages;
    }
    function tryGenCages(size, cageCount, baseCageSize, random) {
      const cells = [], cages = [], assigned = new Set();
      for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) cells.push({ r, c });
      for (let i = 0; i < cageCount; i++) {
        const unassigned = cells.filter(c => !assigned.has(`${c.r},${c.c}`));
        if (unassigned.length === 0) break;
        const start = unassigned[Math.floor(random() * unassigned.length)], cage = [start];
        assigned.add(`${start.r},${start.c}`);
        const targetSize = i === cageCount - 1 ? unassigned.length : Math.max(MIN_CAGE_SIZE, baseCageSize + Math.floor(random() * 3) - 1);
        while (cage.length < targetSize) {
          const neighbors = [];
          for (const cell of cage) for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
            const nr = cell.r + dr, nc = cell.c + dc;
            if (nr >= 0 && nr < size && nc >= 0 && nc < size && !assigned.has(`${nr},${nc}`)) neighbors.push({ r: nr, c: nc });
          }
          if (neighbors.length === 0) break;
          const next = neighbors[Math.floor(random() * neighbors.length)];
          cage.push(next); assigned.add(`${next.r},${next.c}`);
        }
        cages.push(cage);
      }
      for (const cell of cells) if (!assigned.has(`${cell.r},${cell.c}`)) {
        for (const cage of cages) for (const cc of cage) for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) if (cc.r + dr === cell.r && cc.c + dc === cell.c) { cage.push(cell); break; }
      }
      return cages;
    }
    function mergeCages(cages) {
      if (!cages) return [];
      let merged = cages.map(c => [...c]), changed = true;
      while (changed) {
        changed = false;
        for (let i = merged.length - 1; i >= 0; i--) {
          if (merged[i].length < MIN_CAGE_SIZE) {
            let best = -1, bestScore = Infinity;
            for (let j = 0; j < merged.length; j++) {
              if (i === j) continue;
              let adj = false;
              for (const a of merged[i]) for (const b of merged[j]) if ((Math.abs(a.r - b.r) === 1 && a.c === b.c) || (Math.abs(a.c - b.c) === 1 && a.r === b.r)) { adj = true; break; }
              if (adj && merged[i].length + merged[j].length < bestScore) { bestScore = merged[i].length + merged[j].length; best = j; }
            }
            if (best !== -1) { merged[best] = [...merged[best], ...merged[i]]; merged.splice(i, 1); changed = true; break; }
          }
        }
      }
      return merged;
    }
    function countSolutions(numbers, rowSums, colSums, cageSums, cellToCage, size, maxCount = 2) {
      const totalCells = size * size;
      let solutionCount = 0;
      const cRS = new Array(size).fill(0), cCS = new Array(size).fill(0), cCaS = new Array(cageSums.length).fill(0);
      const rR = new Array(size).fill(size), cR = new Array(size).fill(size), caR = {};
      for (let i = 0; i < cageSums.length; i++) caR[i] = 0;
      for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) caR[cellToCage[`${r},${c}`]]++;
      function bt(ci) {
        if (solutionCount >= maxCount) return;
        if (ci === totalCells) { let v = true; for (let r = 0; r < size && v; r++) if (cRS[r] !== rowSums[r]) v = false; for (let c = 0; c < size && v; c++) if (cCS[c] !== colSums[c]) v = false; for (let i = 0; i < cageSums.length && v; i++) if (cCaS[i] !== cageSums[i]) v = false; if (v) solutionCount++; return; }
        const r = Math.floor(ci / size), c = ci % size, v = numbers[r][c], cIdx = cellToCage[`${r},${c}`];
        const nRR = rR[r] - 1, nCR = cR[c] - 1, nCaR = caR[cIdx] - 1;
        const nRS = cRS[r] + v, nCS = cCS[c] + v, nCaS = cCaS[cIdx] + v;
        if (nRS <= rowSums[r] && nCS <= colSums[c] && nCaS <= cageSums[cIdx]) {
          let can = true;
          if (nRR === 0 && nRS !== rowSums[r]) can = false;
          if (can && nCR === 0 && nCS !== colSums[c]) can = false;
          if (can && nCaR === 0 && nCaS !== cageSums[cIdx]) can = false;
          if (can) { cRS[r] = nRS; cCS[c] = nCS; cCaS[cIdx] = nCaS; rR[r] = nRR; cR[c] = nCR; caR[cIdx] = nCaR; bt(ci + 1); cRS[r] -= v; cCS[c] -= v; cCaS[cIdx] -= v; rR[r] = nRR + 1; cR[c] = nCR + 1; caR[cIdx] = nCaR + 1; }
        }
        let canSkip = true;
        if (nRR === 0 && cRS[r] !== rowSums[r]) canSkip = false;
        if (canSkip && nCR === 0 && cCS[c] !== colSums[c]) canSkip = false;
        if (canSkip && nCaR === 0 && cCaS[cIdx] !== cageSums[cIdx]) canSkip = false;
        if (canSkip) { rR[r] = nRR; cR[c] = nCR; caR[cIdx] = nCaR; bt(ci + 1); rR[r] = nRR + 1; cR[c] = nCR + 1; caR[cIdx] = nCaR + 1; }
      }
      bt(0);
      return solutionCount;
    }
    function generatePuzzleWithSeed(difficulty, problemNumber) {
      const config = DIFFICULTIES[difficulty], { size, selectRatio } = config;
      const baseSeed = (difficulty === 'easy' ? 0 : difficulty === 'medium' ? 100000 : 200000) + problemNumber;
      for (let seedOffset = 0; seedOffset < 1000; seedOffset++) {
        const seed = baseSeed * 1000 + seedOffset, random = mulberry32(seed);
        const numbers = [], solution = [];
        for (let r = 0; r < size; r++) { const row = [], srow = []; for (let c = 0; c < size; c++) { row.push(Math.floor(random() * 9) + 1); srow.push(random() < selectRatio); } numbers.push(row); solution.push(srow); }
        for (let r = 0; r < size; r++) if (!solution[r].some(v => v)) solution[r][Math.floor(random() * size)] = true;
        for (let c = 0; c < size; c++) { let has = false; for (let r = 0; r < size; r++) if (solution[r][c]) has = true; if (!has) solution[Math.floor(random() * size)][c] = true; }
        const cages = generateCagesSeeded(size, random);
        const cagesWithColor = cages.map((cage, i) => ({ cells: cage, color: PASTEL_COLORS[i % PASTEL_COLORS.length], colorDark: PASTEL_COLORS_DARK[i % PASTEL_COLORS_DARK.length], id: i }));
        const cellToCage = {};
        cagesWithColor.forEach((cage, ci) => cage.cells.forEach(cell => { cellToCage[`${cell.r},${cell.c}`] = ci; }));
        cagesWithColor.forEach(cage => { if (!cage.cells.some(cell => solution[cell.r][cell.c]) && cage.cells.length > 0) { const rc = cage.cells[Math.floor(random() * cage.cells.length)]; solution[rc.r][rc.c] = true; } });
        const rowSums = [], colSums = [];
        for (let r = 0; r < size; r++) { let s = 0; for (let c = 0; c < size; c++) if (solution[r][c]) s += numbers[r][c]; rowSums.push(s); }
        for (let c = 0; c < size; c++) { let s = 0; for (let r = 0; r < size; r++) if (solution[r][c]) s += numbers[r][c]; colSums.push(s); }
        const cageSums = cagesWithColor.map(cage => cage.cells.reduce((s, cell) => solution[cell.r][cell.c] ? s + numbers[cell.r][cell.c] : s, 0));
        if (countSolutions(numbers, rowSums, colSums, cageSums, cellToCage, size, 2) === 1) return { size, numbers, solution, cages: cagesWithColor, cellToCage, rowSums, colSums, cageSums };
      }
      return null;
    }

    function App() {
      const [screen, setScreen] = useState('home');
      const [difficulty, setDifficulty] = useState('easy');
      const [problemNumber, setProblemNumber] = useState(1);
      const [progress, setProgress] = useState(loadProgress);
      const [lives, setLives] = useState(loadLives);
      const [settings, setSettings] = useState(loadSettings);
      const [puzzle, setPuzzle] = useState(null);
      const [cellStates, setCellStates] = useState({});
      const [mode, setMode] = useState('select');
      const [gameLives, setGameLives] = useState(GAME_LIVES);
      const [wrongCell, setWrongCell] = useState(null);
      const [hintedCell, setHintedCell] = useState(null);
      const [hintsUsed, setHintsUsed] = useState(0);
      const [showResult, setShowResult] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [timer, setTimer] = useState(0);
      const [mistakes, setMistakes] = useState(0);
      const timerRef = useRef(null);

      useEffect(() => { document.documentElement.setAttribute('data-theme', settings.darkMode ? 'dark' : 'light'); }, [settings.darkMode]);
      useEffect(() => { soundManager.enabled = settings.sound; }, [settings.sound]);
      useEffect(() => { const i = setInterval(() => { setLives(prev => { if (prev.current >= MAX_LIVES) return prev; const now = Date.now(), elapsed = now - prev.lastUpdate; if (elapsed >= LIFE_RECOVERY_MINUTES * 60 * 1000) { const nl = Math.min(MAX_LIVES, prev.current + 1), updated = { current: nl, lastUpdate: now }; saveLives(updated); return updated; } return prev; }); }, 1000); return () => clearInterval(i); }, []);
      useEffect(() => { if (screen === 'game' && puzzle && !showResult) { timerRef.current = setInterval(() => setTimer(t => t + 1), 1000); } else { clearInterval(timerRef.current); } return () => clearInterval(timerRef.current); }, [screen, puzzle, showResult]);

      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
      const getNextRecoveryTime = () => { if (lives.current >= MAX_LIVES) return null; const remaining = LIFE_RECOVERY_MINUTES * 60 * 1000 - (Date.now() - lives.lastUpdate); if (remaining <= 0) return '0:00'; return `${Math.floor(remaining / 60000)}:${Math.floor((remaining % 60000) / 1000).toString().padStart(2, '0')}`; };
      const getTotalCleared = () => Object.values(progress).reduce((t, d) => t + Object.keys(d).filter(k => d[k]?.cleared).length, 0);
      const getDifficultyCleared = (d) => Object.keys(progress[d] || {}).filter(k => progress[d][k]?.cleared).length;
      const updateSettings = (k, v) => { const ns = { ...settings, [k]: v }; setSettings(ns); saveSettings(ns); };

      const startGame = (diff, num) => {
        if (lives.current <= 0) { alert('„É©„Ç§„Éï„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂõûÂæ©„Çí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ'); return; }
        setDifficulty(diff); setProblemNumber(num); setIsLoading(true); setScreen('game');
        setCellStates({}); setMode('select'); setGameLives(GAME_LIVES); setShowResult(null);
        setTimer(0); setMistakes(0); setHintsUsed(0); setHintedCell(null);
        const nl = { current: lives.current - 1, lastUpdate: lives.current >= MAX_LIVES ? Date.now() : lives.lastUpdate };
        setLives(nl); saveLives(nl);
        setTimeout(() => { setPuzzle(generatePuzzleWithSeed(diff, num)); setIsLoading(false); }, 50);
      };

      const useHint = () => {
        if (!puzzle || hintsUsed >= MAX_HINTS || showResult) return;
        const undecided = [];
        for (let r = 0; r < puzzle.size; r++) for (let c = 0; c < puzzle.size; c++) { const k = `${r},${c}`, s = cellStates[k]; if (s !== 'selected' && s !== 'erased') undecided.push({ r, c, key: k, isAnswer: puzzle.solution[r][c] }); }
        if (undecided.length === 0) return;
        const rc = undecided[Math.floor(Math.random() * undecided.length)];
        soundManager.play('hint'); setHintsUsed(h => h + 1); setHintedCell(rc.key); setTimeout(() => setHintedCell(null), 500);
        setCellStates(prev => ({ ...prev, [rc.key]: rc.isAnswer ? 'selected' : 'erased' }));
      };

      const handleCellClick = useCallback((r, c) => {
        if (!puzzle || showResult) return;
        const key = `${r},${c}`, currentState = cellStates[key], isCorrect = puzzle.solution[r][c];
        if (currentState === 'selected' && isCorrect) return;
        if (currentState === 'erased' && !isCorrect) return;
        let isWrong = false;
        if (mode === 'select') { if (!isCorrect && currentState !== 'selected') isWrong = true; }
        else { if (isCorrect && currentState !== 'erased') isWrong = true; }
        if (isWrong) {
          soundManager.play('wrong'); setWrongCell(key); setTimeout(() => setWrongCell(null), 400); setMistakes(m => m + 1);
          setGameLives(prev => { const nl = prev - 1; if (nl <= 0) setTimeout(() => { soundManager.play('gameover'); setShowResult('gameover'); }, 300); return nl; });
          return;
        }
        soundManager.play(mode === 'select' ? 'select' : 'erase');
        setCellStates(prev => { const next = mode === 'select' ? (prev[key] === 'selected' ? undefined : 'selected') : (prev[key] === 'erased' ? undefined : 'erased'); if (next === undefined) { const ns = { ...prev }; delete ns[key]; return ns; } return { ...prev, [key]: next }; });
      }, [mode, puzzle, cellStates, showResult]);

      const calculateSums = useMemo(() => {
        if (!puzzle) return { rows: [], cols: [], cages: [] };
        const { size, numbers, cages } = puzzle, rowSums = [], colSums = [];
        for (let r = 0; r < size; r++) { let s = 0; for (let c = 0; c < size; c++) if (cellStates[`${r},${c}`] === 'selected') s += numbers[r][c]; rowSums.push(s); }
        for (let c = 0; c < size; c++) { let s = 0; for (let r = 0; r < size; r++) if (cellStates[`${r},${c}`] === 'selected') s += numbers[r][c]; colSums.push(s); }
        return { rows: rowSums, cols: colSums, cages: cages.map(cage => cage.cells.reduce((s, cell) => cellStates[`${cell.r},${cell.c}`] === 'selected' ? s + numbers[cell.r][cell.c] : s, 0)) };
      }, [puzzle, cellStates]);

      const checkStatus = useMemo(() => {
        if (!puzzle) return { completed: false, rows: [], cols: [], cages: [], rowsOver: [], colsOver: [], cagesOver: [] };
        const { size, cages, rowSums, colSums, cageSums } = puzzle;
        const rowsFull = [], colsFull = [], cagesFull = [];
        for (let r = 0; r < size; r++) { let f = true; for (let c = 0; c < size; c++) { const s = cellStates[`${r},${c}`]; if (s !== 'selected' && s !== 'erased') { f = false; break; } } rowsFull.push(f); }
        for (let c = 0; c < size; c++) { let f = true; for (let r = 0; r < size; r++) { const s = cellStates[`${r},${c}`]; if (s !== 'selected' && s !== 'erased') { f = false; break; } } colsFull.push(f); }
        cages.forEach(cage => cagesFull.push(cage.cells.every(cell => { const s = cellStates[`${cell.r},${cell.c}`]; return s === 'selected' || s === 'erased'; })));
        const rowsComplete = rowSums.map((t, i) => rowsFull[i] && calculateSums.rows[i] === t);
        const colsComplete = colSums.map((t, i) => colsFull[i] && calculateSums.cols[i] === t);
        const cagesComplete = cageSums.map((t, i) => cagesFull[i] && calculateSums.cages[i] === t);
        return { completed: rowsComplete.every(Boolean) && colsComplete.every(Boolean) && cagesComplete.every(Boolean), rows: rowsComplete, cols: colsComplete, cages: cagesComplete, rowsOver: rowSums.map((t, i) => calculateSums.rows[i] > t), colsOver: colSums.map((t, i) => calculateSums.cols[i] > t), cagesOver: cageSums.map((t, i) => calculateSums.cages[i] > t) };
      }, [puzzle, cellStates, calculateSums]);

      useEffect(() => {
        if (checkStatus.completed && puzzle && !showResult) {
          soundManager.play('clear');
          const stars = mistakes === 0 && hintsUsed === 0 ? 3 : mistakes <= 1 && hintsUsed <= 1 ? 2 : 1;
          const np = { ...progress }; if (!np[difficulty]) np[difficulty] = {};
          const ex = np[difficulty][problemNumber];
          if (!ex || !ex.cleared || ex.time > timer || ex.stars < stars) { np[difficulty][problemNumber] = { cleared: true, time: timer, mistakes, hints: hintsUsed, stars }; setProgress(np); saveProgress(np); }
          setShowResult('clear');
        }
      }, [checkStatus.completed]);

      const cellCageResolved = useMemo(() => {
        if (!puzzle) return {};
        const { size, cellToCage } = puzzle, resolved = {};
        for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) { const k = `${r},${c}`; if (checkStatus.cages[cellToCage[k]]) resolved[k] = true; }
        return resolved;
      }, [puzzle, checkStatus]);

      if (screen === 'settings') return (
        <div className="app"><div className="settings-screen">
          <div className="settings-header"><button className="back-btn" onClick={() => setScreen('home')}>‚Üê</button><span className="settings-title">Ë®≠ÂÆö</span></div>
          <div className="settings-list">
            <div className="settings-item"><div><div className="settings-item-label">üîä „Çµ„Ç¶„É≥„Éâ</div><div className="settings-item-desc">ÂäπÊûúÈü≥„ÅÆON/OFF</div></div><div className={`toggle ${settings.sound ? 'active' : ''}`} onClick={() => updateSettings('sound', !settings.sound)} /></div>
            <div className="settings-item"><div><div className="settings-item-label">üåô „ÉÄ„Éº„ÇØ„É¢„Éº„Éâ</div><div className="settings-item-desc">ÁõÆ„Å´ÂÑ™„Åó„ÅÑÊöó„ÅÑ„ÉÜ„Éº„Éû</div></div><div className={`toggle ${settings.darkMode ? 'active' : ''}`} onClick={() => updateSettings('darkMode', !settings.darkMode)} /></div>
          </div>
        </div></div>
      );

      if (screen === 'home') {
        const rt = getNextRecoveryTime();
        return (
          <div className="app"><div className="home-screen">
            <div className="home-logo">üî¢</div><h1 className="home-title">Number Sums</h1><p className="home-subtitle">Êï∞Â≠ó„Éë„Ç∫„É´„Ç≤„Éº„É†</p>
            <button className="home-btn primary" onClick={() => { for (const d of ['easy', 'medium', 'hard']) { for (let i = 1; i <= DIFFICULTIES[d].problems; i++) if (!progress[d]?.[i]?.cleared) { startGame(d, i); return; } } setScreen('select'); }}>Á∂ö„Åç„Åã„Çâ„Éó„É¨„Ç§</button>
            <button className="home-btn secondary" onClick={() => setScreen('select')}>ÂïèÈ°å„ÇíÈÅ∏„Å∂</button>
            <button className="home-btn settings" onClick={() => setScreen('settings')}>‚öôÔ∏è Ë®≠ÂÆö</button>
            <div className="lives-display"><div className="lives-hearts">{Array.from({ length: MAX_LIVES }).map((_, i) => <span key={i} style={{ opacity: i < lives.current ? 1 : 0.3 }}>‚ù§Ô∏è</span>)}</div>{rt ? <div className="lives-timer">Ê¨°„ÅÆÂõûÂæ©„Åæ„Åß: {rt}</div> : <div className="lives-full">„É©„Ç§„ÉïÊ∫Ä„Çø„É≥</div>}</div>
            <div className="home-stats"><div className="stat-item"><div className="stat-value">{getTotalCleared()}</div><div className="stat-label">„ÇØ„É™„Ç¢Êï∞</div></div><div className="stat-item"><div className="stat-value">{getDifficultyCleared('easy')}/{DIFFICULTIES.easy.problems}</div><div className="stat-label">Á∞°Âçò</div></div><div className="stat-item"><div className="stat-value">{getDifficultyCleared('medium')}/{DIFFICULTIES.medium.problems}</div><div className="stat-label">ÊôÆÈÄö</div></div></div>
          </div></div>
        );
      }

      if (screen === 'select') {
        const config = DIFFICULTIES[difficulty];
        return (
          <div className="app"><div className="select-screen">
            <div className="select-header"><button className="back-btn" onClick={() => setScreen('home')}>‚Üê</button><span className="select-title">ÂïèÈ°å„ÇíÈÅ∏„Å∂</span><span style={{ fontSize: '20px' }}>{'‚ù§Ô∏è'.repeat(lives.current)}{'üñ§'.repeat(MAX_LIVES - lives.current)}</span></div>
            <div className="diff-tabs">{Object.entries(DIFFICULTIES).map(([k, cfg]) => <button key={k} className={`diff-tab ${difficulty === k ? 'active' : ''}`} onClick={() => setDifficulty(k)}>{cfg.label}<div className="count">{getDifficultyCleared(k)}/{cfg.problems}</div></button>)}</div>
            <div className="problem-grid">{Array.from({ length: config.problems }).map((_, i) => { const num = i + 1, data = progress[difficulty]?.[num], cleared = data?.cleared, stars = data?.stars || 0; return <button key={num} className={`problem-btn ${cleared ? 'cleared' : ''}`} onClick={() => startGame(difficulty, num)}>{num}{cleared && <div className="stars">{'‚≠ê'.repeat(stars)}</div>}</button>; })}</div>
          </div></div>
        );
      }

      if (screen === 'game') {
        if (isLoading || !puzzle) return <div className="app"><div className="game-screen"><div className="game-header"><button className="back-btn" onClick={() => setScreen('select')}>‚Üê</button><span className="problem-number">No.{problemNumber}</span><span></span></div><div className="loading"><div className="loading-spinner"></div><div className="loading-text">„Éë„Ç∫„É´„ÇíÁîüÊàê‰∏≠...</div></div></div></div>;
        const { size, numbers, cages, cellToCage, rowSums, colSums, cageSums } = puzzle;
        return (
          <div className="app"><div className="game-screen">
            <div className="game-header"><div className="game-info"><button className="back-btn" onClick={() => setScreen('select')}>‚Üê</button><span className="problem-number">{DIFFICULTIES[difficulty].label} No.{problemNumber}</span></div><span className="game-timer">{formatTime(timer)}</span><span className="game-lives">{'‚ù§Ô∏è'.repeat(gameLives)}{'üñ§'.repeat(GAME_LIVES - gameLives)}</span></div>
            <div className="game-main">
              {showResult && <div className="overlay"><div className="modal">
                {showResult === 'clear' ? (<><div className="modal-emoji">üéâ</div><div className="modal-title">„ÇØ„É™„Ç¢ÔºÅ</div><div className="modal-stars">{'‚≠ê'.repeat(mistakes === 0 && hintsUsed === 0 ? 3 : mistakes <= 1 && hintsUsed <= 1 ? 2 : 1)}</div><div className="modal-stats"><div className="modal-stat"><div className="modal-stat-value">{formatTime(timer)}</div><div className="modal-stat-label">„Çø„Ç§„É†</div></div><div className="modal-stat"><div className="modal-stat-value">{mistakes}</div><div className="modal-stat-label">„Éü„Çπ</div></div><div className="modal-stat"><div className="modal-stat-value">{hintsUsed}</div><div className="modal-stat-label">„Éí„É≥„Éà</div></div></div><button className="modal-btn" onClick={() => { const next = problemNumber + 1; if (next <= DIFFICULTIES[difficulty].problems) startGame(difficulty, next); else setScreen('select'); }}>Ê¨°„ÅÆÂïèÈ°å„Å∏</button><button className="modal-btn secondary" onClick={() => setScreen('select')}>ÂïèÈ°åÈÅ∏Êäû„Å´Êàª„Çã</button></>) : (<><div className="modal-emoji">üíî</div><div className="modal-title gameover">„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</div><div className="modal-stats"><div className="modal-stat"><div className="modal-stat-value">{formatTime(timer)}</div><div className="modal-stat-label">„Çø„Ç§„É†</div></div><div className="modal-stat"><div className="modal-stat-value">{mistakes}</div><div className="modal-stat-label">„Éü„Çπ</div></div></div><button className="modal-btn" onClick={() => startGame(difficulty, problemNumber)}>„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶</button><button className="modal-btn secondary" onClick={() => setScreen('select')}>ÂïèÈ°åÈÅ∏Êäû„Å´Êàª„Çã</button></>)}
              </div></div>}
              <div className="board-container">
                <div className="col-sums">{colSums.map((sum, c) => <div key={c} className={`sum-box ${checkStatus.cols[c] ? 'complete' : checkStatus.colsOver?.[c] ? 'over' : ''}`}>{calculateSums.cols[c] > 0 && <span className="current">{calculateSums.cols[c]}</span>}{sum}</div>)}</div>
                <div className="board-row">
                  <div className="row-sums">{rowSums.map((sum, r) => <div key={r} className={`row-sum-box ${checkStatus.rows[r] ? 'complete' : checkStatus.rowsOver?.[r] ? 'over' : ''}`}>{calculateSums.rows[r] > 0 && <span className="current">{calculateSums.rows[r]}</span>}{sum}</div>)}</div>
                  <div className="grid" style={{ gridTemplateColumns: `repeat(${size}, 1fr)` }}>
                    {Array.from({ length: size }).map((_, r) => Array.from({ length: size }).map((_, c) => {
                      const key = `${r},${c}`, state = cellStates[key], cageIndex = cellToCage[key], cage = cages[cageIndex], value = numbers[r][c];
                      const isCageResolved = cellCageResolved[key], isWrong = wrongCell === key, isHinted = hintedCell === key;
                      const isTopLeft = cage.cells.every(cell => cell.r > r || (cell.r === r && cell.c >= c));
                      const bgColor = isCageResolved ? 'var(--bg-primary)' : settings.darkMode ? cage.colorDark : cage.color;
                      return <div key={key} className={`cell ${state === 'selected' ? 'selected' : state === 'erased' ? 'erased' : ''} ${isCageResolved ? 'cage-resolved' : ''} ${isWrong ? 'wrong' : ''} ${isHinted ? 'hinted' : ''}`} style={{ backgroundColor: bgColor, borderRight: c === size - 1 ? 'none' : undefined, borderBottom: r === size - 1 ? 'none' : undefined }} onClick={() => handleCellClick(r, c)}>
                        {isTopLeft && <span className={`cage-hint ${checkStatus.cages[cageIndex] ? 'complete' : checkStatus.cagesOver?.[cageIndex] ? 'over' : ''}`}>{cageSums[cageIndex]}</span>}
                        <span className="number">{value}</span>
                      </div>;
                    }))}
                  </div>
                </div>
              </div>
              <div className="controls">
                <div className="mode-switch"><button className={`mode-btn ${mode === 'select' ? 'active' : ''}`} onClick={() => setMode('select')}><span className="icon">‚≠ï</span><span className="label">ÈÅ∏Êäû</span></button><button className={`mode-btn ${mode === 'erase' ? 'active' : ''}`} onClick={() => setMode('erase')}><span className="icon">‚úï</span><span className="label">Ê∂àÂéª</span></button></div>
                <div className="game-actions"><button className="action-btn hint" onClick={useHint} disabled={hintsUsed >= MAX_HINTS}>üí° „Éí„É≥„Éà ({MAX_HINTS - hintsUsed})</button><button className="action-btn reset" onClick={() => setCellStates({})}>üîÑ „É™„Çª„ÉÉ„Éà</button></div>
              </div>
            </div>
          </div></div>
        );
      }
      return null;
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
  <script>if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('./sw.js').then(r => console.log('SW registered:', r.scope)).catch(e => console.log('SW failed:', e)); }); }</script>
</body>
</html>
