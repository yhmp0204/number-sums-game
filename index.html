<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Number Sums</title>
  
  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Number Sums">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  
  <!-- SEO -->
  <meta name="description" content="Êï∞Â≠ó„ÇíÈÅ∏„Çì„ÅßÂêàË®à„ÇíÁõÆÊ®ôÂÄ§„Å´Âêà„Çè„Åõ„Çã„Éë„Ç∫„É´„Ç≤„Éº„É†„ÄÇ2500Âïè„ÅÆÂõ∫ÂÆö„Éë„Ç∫„É´„Å´ÊåëÊà¶ÔºÅ">
  <meta name="keywords" content="„Éë„Ç∫„É´,Êï∞Â≠ó,„Ç≤„Éº„É†,ËÑ≥„Éà„É¨,Number Sums">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      touch-action: manipulation;
    }
    .app {
      min-height: 100vh;
      max-width: 500px;
      margin: 0 auto;
      background: #fff;
      position: relative;
    }
    
    /* ===== „Éõ„Éº„É†ÁîªÈù¢ ===== */
    .home-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px 20px;
      background: linear-gradient(180deg, #f8f9ff 0%, #fff 100%);
    }
    .home-logo {
      font-size: 48px;
      margin-bottom: 8px;
    }
    .home-title {
      font-size: 32px;
      font-weight: 800;
      color: #333;
      margin-bottom: 8px;
    }
    .home-subtitle {
      font-size: 14px;
      color: #888;
      margin-bottom: 40px;
    }
    .home-btn {
      width: 100%;
      max-width: 280px;
      padding: 16px 24px;
      border-radius: 16px;
      font-size: 18px;
      font-weight: 700;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 12px;
    }
    .home-btn:active { transform: scale(0.98); }
    .home-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    .home-btn.secondary {
      background: #f5f5f5;
      color: #333;
    }
    .home-stats {
      margin-top: 40px;
      display: flex;
      gap: 24px;
    }
    .stat-item {
      text-align: center;
    }
    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: #5c6bc0;
    }
    .stat-label {
      font-size: 12px;
      color: #888;
    }
    .lives-display {
      margin-top: 32px;
      text-align: center;
    }
    .lives-hearts {
      font-size: 32px;
      letter-spacing: 4px;
    }
    .lives-timer {
      font-size: 13px;
      color: #888;
      margin-top: 8px;
    }
    .lives-full {
      font-size: 13px;
      color: #4caf50;
      margin-top: 8px;
    }
    
    /* ===== ÂïèÈ°åÈÅ∏ÊäûÁîªÈù¢ ===== */
    .select-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: #f8f9ff;
    }
    .select-header {
      padding: 16px;
      background: #fff;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #eee;
    }
    .back-btn {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      border: none;
      background: #f0f0f0;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .select-title {
      font-size: 18px;
      font-weight: 700;
      flex: 1;
    }
    .diff-tabs {
      display: flex;
      padding: 12px 16px;
      gap: 8px;
      background: #fff;
    }
    .diff-tab {
      flex: 1;
      padding: 12px;
      border-radius: 12px;
      border: 2px solid #eee;
      background: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
    }
    .diff-tab.active {
      border-color: #5c6bc0;
      background: #f0f0ff;
      color: #5c6bc0;
    }
    .diff-tab .count {
      font-size: 11px;
      color: #888;
      margin-top: 2px;
    }
    .diff-tab.active .count {
      color: #5c6bc0;
    }
    .problem-grid {
      flex: 1;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      overflow-y: auto;
      align-content: start;
    }
    .problem-btn {
      aspect-ratio: 1;
      border-radius: 12px;
      border: 2px solid #e0e0e0;
      background: #fff;
      font-size: 16px;
      font-weight: 700;
      color: #333;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .problem-btn:active { transform: scale(0.95); }
    .problem-btn.cleared {
      background: #e8f5e9;
      border-color: #4caf50;
      color: #4caf50;
    }
    .problem-btn.cleared .stars {
      font-size: 8px;
      margin-top: 2px;
    }
    .problem-btn.current {
      border-color: #5c6bc0;
      background: #f0f0ff;
    }
    .problem-btn.locked {
      background: #f5f5f5;
      color: #ccc;
      cursor: not-allowed;
    }
    
    /* ===== „Ç≤„Éº„É†ÁîªÈù¢ ===== */
    .game-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: #fff;
    }
    .game-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #eee;
    }
    .game-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .problem-number {
      font-size: 16px;
      font-weight: 700;
      color: #333;
    }
    .game-timer {
      font-size: 14px;
      color: #888;
      font-variant-numeric: tabular-nums;
    }
    .game-lives {
      font-size: 20px;
    }
    .game-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px 8px;
      gap: 12px;
    }
    
    /* „Éú„Éº„ÉâÈñ¢ÈÄ£ÔºàÊó¢Â≠ò„Çπ„Çø„Ç§„É´Ôºâ */
    .board-container {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .col-sums {
      display: flex;
      margin-left: 44px;
    }
    .sum-box {
      width: 44px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      font-weight: 700;
      color: #333;
      position: relative;
    }
    .sum-box.complete { color: #aaa; text-decoration: line-through; }
    .sum-box.over { color: #e53935; }
    .sum-box .current {
      position: absolute;
      top: -2px;
      right: 1px;
      font-size: 9px;
      font-weight: 600;
      color: #888;
    }
    .sum-box.complete .current { display: none; }
    .board-row {
      display: flex;
      gap: 2px;
    }
    .row-sums {
      display: flex;
      flex-direction: column;
    }
    .row-sum-box {
      width: 42px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      font-weight: 700;
      color: #333;
      position: relative;
    }
    .row-sum-box.complete { color: #aaa; text-decoration: line-through; }
    .row-sum-box.over { color: #e53935; }
    .row-sum-box .current {
      position: absolute;
      top: 2px;
      right: 1px;
      font-size: 9px;
      font-weight: 600;
      color: #888;
    }
    .row-sum-box.complete .current { display: none; }
    .grid {
      display: grid;
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
    }
    .cell {
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 700;
      cursor: pointer;
      position: relative;
      border-right: 1px solid #e0e0e0;
      border-bottom: 1px solid #e0e0e0;
      -webkit-tap-highlight-color: transparent;
      transition: background-color 0.2s;
      color: #333;
    }
    .cell:active { opacity: 0.7; }
    .cell .cage-hint {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      font-weight: 700;
      color: #333;
      background: rgba(255,255,255,0.85);
      padding: 0 3px;
      border-radius: 3px;
      line-height: 1.2;
      z-index: 10;
    }
    .cell .cage-hint.complete { color: #4caf50; text-decoration: line-through; background: rgba(255,255,255,0.9); }
    .cell .cage-hint.over { color: #e53935; background: rgba(255,255,255,0.9); }
    .cell.selected .number {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 34px;
      height: 34px;
      border: 2.5px solid #333;
      border-radius: 50%;
      background: rgba(255,255,255,0.5);
    }
    .cell.erased .number { visibility: hidden; }
    .cell.cage-resolved { background-color: #fff !important; }
    .cell.wrong { animation: shake 0.4s; }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-4px); }
      40%, 80% { transform: translateX(4px); }
    }
    
    .controls {
      width: 100%;
      max-width: 340px;
      padding: 12px;
    }
    .mode-switch {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .mode-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 10px 20px;
      border-radius: 12px;
      border: 2px solid #eee;
      background: #fff;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mode-btn.active {
      border-color: #5c6bc0;
      background: #f0f0ff;
    }
    .mode-btn .icon { font-size: 18px; }
    .mode-btn .label { font-size: 11px; font-weight: 600; color: #666; }
    .mode-btn.active .label { color: #5c6bc0; }
    .game-actions {
      display: flex;
      gap: 8px;
    }
    .action-btn {
      flex: 1;
      padding: 12px;
      border-radius: 12px;
      border: none;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .action-btn.hint {
      background: #fff3e0;
      color: #f57c00;
    }
    .action-btn.reset {
      background: #f5f5f5;
      color: #666;
    }
    
    /* ===== ÁµêÊûúÁîªÈù¢Ôºà„É¢„Éº„ÉÄ„É´Ôºâ ===== */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      animation: fadeIn 0.3s;
    }
    .modal {
      background: white;
      border-radius: 24px;
      padding: 32px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      animation: bounceIn 0.5s;
      max-width: 320px;
      width: 90%;
    }
    .modal-emoji { font-size: 56px; margin-bottom: 12px; }
    .modal-title { font-size: 24px; font-weight: 700; color: #333; margin-bottom: 8px; }
    .modal-title.gameover { color: #e53935; }
    .modal-stars { font-size: 32px; margin-bottom: 8px; }
    .modal-stats {
      display: flex;
      justify-content: center;
      gap: 24px;
      margin-bottom: 20px;
    }
    .modal-stat {
      text-align: center;
    }
    .modal-stat-value {
      font-size: 20px;
      font-weight: 700;
      color: #5c6bc0;
    }
    .modal-stat-label {
      font-size: 11px;
      color: #888;
    }
    .modal-btn {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 8px;
    }
    .modal-btn.secondary {
      background: #f5f5f5;
      color: #333;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes bounceIn {
      0% { transform: scale(0.3); opacity: 0; }
      50% { transform: scale(1.05); }
      70% { transform: scale(0.9); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* „É≠„Éº„Éá„Ç£„É≥„Ç∞ */
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
      gap: 16px;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f0f0f0;
      border-top-color: #5c6bc0;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { color: #666; font-size: 14px; }
    
    @media (max-width: 380px) {
      .cell { width: 38px; height: 38px; font-size: 17px; }
      .cell.selected .number { width: 28px; height: 28px; }
      .sum-box { width: 38px; height: 28px; font-size: 13px; }
      .row-sum-box { width: 36px; height: 38px; font-size: 13px; }
      .col-sums { margin-left: 38px; }
      .cell .cage-hint { font-size: 8px; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, useRef } = React;

    // ========== ÂÆöÊï∞ ==========
    const PASTEL_COLORS = [
      '#FFCDD2', '#B3E5FC', '#C8E6C9', '#FFE0B2', '#E1BEE7', '#FFF9C4',
      '#B2EBF2', '#F8BBD0', '#DCEDC8', '#D7CCC8', '#CFD8DC', '#F0F4C3',
    ];

    const DIFFICULTIES = {
      easy: { size: 7, selectRatio: 0.5, label: 'Á∞°Âçò', problems: 500 },
      medium: { size: 8, selectRatio: 0.45, label: 'ÊôÆÈÄö', problems: 1000 },
      hard: { size: 9, selectRatio: 0.4, label: 'Èõ£„Åó„ÅÑ', problems: 1000 },
    };

    const MAX_LIVES = 5;
    const LIFE_RECOVERY_MINUTES = 30;
    const MIN_CAGE_SIZE = 6;
    const GAME_LIVES = 2; // „Ç≤„Éº„É†ÂÜÖ„Éü„ÇπË®±ÂÆπÂõûÊï∞

    // ========== „Ç∑„Éº„Éâ‰ªò„Åç‰π±Êï∞ÁîüÊàê ==========
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // ========== LocalStorage ==========
    function loadProgress() {
      try {
        const data = localStorage.getItem('numberSumsProgress');
        return data ? JSON.parse(data) : { easy: {}, medium: {}, hard: {} };
      } catch { return { easy: {}, medium: {}, hard: {} }; }
    }

    function saveProgress(progress) {
      try {
        localStorage.setItem('numberSumsProgress', JSON.stringify(progress));
      } catch {}
    }

    function loadLives() {
      try {
        const data = localStorage.getItem('numberSumsLives');
        if (data) {
          const parsed = JSON.parse(data);
          // ÊôÇÈñìÁµåÈÅé„Å´„Çà„ÇãÂõûÂæ©Ë®àÁÆó
          const now = Date.now();
          const elapsed = now - parsed.lastUpdate;
          const recovered = Math.floor(elapsed / (LIFE_RECOVERY_MINUTES * 60 * 1000));
          const newLives = Math.min(MAX_LIVES, parsed.current + recovered);
          const newLastUpdate = parsed.lastUpdate + recovered * LIFE_RECOVERY_MINUTES * 60 * 1000;
          return { current: newLives, lastUpdate: newLives >= MAX_LIVES ? now : newLastUpdate };
        }
      } catch {}
      return { current: MAX_LIVES, lastUpdate: Date.now() };
    }

    function saveLives(lives) {
      try {
        localStorage.setItem('numberSumsLives', JSON.stringify(lives));
      } catch {}
    }

    // ========== „Ç±„Éº„Ç∏ÁîüÊàêÔºà„Ç∑„Éº„Éâ‰ªò„ÅçÔºâ ==========
    function generateCagesSeeded(size, random) {
      const totalCells = size * size;
      const cageCount = size;
      const baseCageSize = Math.floor(totalCells / cageCount);
      
      let cages = null;
      let attempts = 0;
      const maxAttempts = 50;
      
      while (attempts < maxAttempts) {
        attempts++;
        cages = tryGenerateCagesSeeded(size, cageCount, baseCageSize, random);
        if (cages && cages.every(cage => cage.length >= MIN_CAGE_SIZE)) {
          break;
        }
      }
      
      if (!cages || !cages.every(cage => cage.length >= MIN_CAGE_SIZE)) {
        cages = mergeSmallerCages(cages, size);
      }
      
      return cages;
    }
    
    function tryGenerateCagesSeeded(size, cageCount, baseCageSize, random) {
      const cells = [];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          cells.push({ r, c });
        }
      }
      
      const cages = [];
      const assigned = new Set();
      
      for (let i = 0; i < cageCount; i++) {
        const unassigned = cells.filter(cell => !assigned.has(`${cell.r},${cell.c}`));
        if (unassigned.length === 0) break;
        
        const start = unassigned[Math.floor(random() * unassigned.length)];
        const cage = [start];
        assigned.add(`${start.r},${start.c}`);
        
        const isLastCage = i === cageCount - 1;
        const targetSize = isLastCage ? unassigned.length : Math.max(MIN_CAGE_SIZE, baseCageSize + Math.floor(random() * 3) - 1);
        
        while (cage.length < targetSize) {
          const neighbors = [];
          for (const cell of cage) {
            const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dr, dc] of dirs) {
              const nr = cell.r + dr, nc = cell.c + dc;
              if (nr >= 0 && nr < size && nc >= 0 && nc < size && !assigned.has(`${nr},${nc}`)) {
                neighbors.push({ r: nr, c: nc });
              }
            }
          }
          if (neighbors.length === 0) break;
          const next = neighbors[Math.floor(random() * neighbors.length)];
          cage.push(next);
          assigned.add(`${next.r},${next.c}`);
        }
        cages.push(cage);
      }
      
      for (const cell of cells) {
        if (!assigned.has(`${cell.r},${cell.c}`)) {
          let added = false;
          for (const cage of cages) {
            for (const cageCell of cage) {
              const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
              for (const [dr, dc] of dirs) {
                if (cageCell.r + dr === cell.r && cageCell.c + dc === cell.c) {
                  cage.push(cell);
                  added = true;
                  break;
                }
              }
              if (added) break;
            }
            if (added) break;
          }
          if (!added && cages.length > 0) {
            cages[cages.length - 1].push(cell);
          }
        }
      }
      
      return cages;
    }
    
    function mergeSmallerCages(cages, size) {
      if (!cages) return [];
      let merged = [...cages.map(cage => [...cage])];
      let changed = true;
      while (changed) {
        changed = false;
        for (let i = merged.length - 1; i >= 0; i--) {
          if (merged[i].length < MIN_CAGE_SIZE) {
            let bestNeighbor = -1;
            let bestScore = Infinity;
            for (let j = 0; j < merged.length; j++) {
              if (i === j) continue;
              let isAdjacent = false;
              for (const cellA of merged[i]) {
                for (const cellB of merged[j]) {
                  const dr = Math.abs(cellA.r - cellB.r);
                  const dc = Math.abs(cellA.c - cellB.c);
                  if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                    isAdjacent = true;
                    break;
                  }
                }
                if (isAdjacent) break;
              }
              if (isAdjacent) {
                const newSize = merged[i].length + merged[j].length;
                if (newSize < bestScore) {
                  bestScore = newSize;
                  bestNeighbor = j;
                }
              }
            }
            if (bestNeighbor !== -1) {
              merged[bestNeighbor] = [...merged[bestNeighbor], ...merged[i]];
              merged.splice(i, 1);
              changed = true;
              break;
            }
          }
        }
      }
      return merged;
    }

    // ========== Ëß£„ÅÆ‰∏ÄÊÑèÊÄß„ÉÅ„Çß„ÉÉ„ÇØ ==========
    function countSolutions(numbers, rowSums, colSums, cageSums, cellToCage, size, maxCount = 2) {
      const totalCells = size * size;
      let solutionCount = 0;
      const currentRowSums = new Array(size).fill(0);
      const currentColSums = new Array(size).fill(0);
      const currentCageSums = new Array(cageSums.length).fill(0);
      const rowRemaining = new Array(size).fill(size);
      const colRemaining = new Array(size).fill(size);
      const cageRemaining = {};
      for (let i = 0; i < cageSums.length; i++) cageRemaining[i] = 0;
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          cageRemaining[cellToCage[`${r},${c}`]]++;
        }
      }
      
      function backtrack(cellIndex) {
        if (solutionCount >= maxCount) return;
        if (cellIndex === totalCells) {
          let valid = true;
          for (let r = 0; r < size && valid; r++) if (currentRowSums[r] !== rowSums[r]) valid = false;
          for (let c = 0; c < size && valid; c++) if (currentColSums[c] !== colSums[c]) valid = false;
          for (let i = 0; i < cageSums.length && valid; i++) if (currentCageSums[i] !== cageSums[i]) valid = false;
          if (valid) solutionCount++;
          return;
        }
        
        const r = Math.floor(cellIndex / size);
        const c = cellIndex % size;
        const value = numbers[r][c];
        const cageIdx = cellToCage[`${r},${c}`];
        const newRowRemaining = rowRemaining[r] - 1;
        const newColRemaining = colRemaining[c] - 1;
        const newCageRemaining = cageRemaining[cageIdx] - 1;
        
        // ÈÅ∏Êäû„Åô„ÇãÂ†¥Âêà
        const newRowSum = currentRowSums[r] + value;
        const newColSum = currentColSums[c] + value;
        const newCageSum = currentCageSums[cageIdx] + value;
        if (newRowSum <= rowSums[r] && newColSum <= colSums[c] && newCageSum <= cageSums[cageIdx]) {
          let canSelect = true;
          if (newRowRemaining === 0 && newRowSum !== rowSums[r]) canSelect = false;
          if (canSelect && newColRemaining === 0 && newColSum !== colSums[c]) canSelect = false;
          if (canSelect && newCageRemaining === 0 && newCageSum !== cageSums[cageIdx]) canSelect = false;
          if (canSelect) {
            currentRowSums[r] = newRowSum;
            currentColSums[c] = newColSum;
            currentCageSums[cageIdx] = newCageSum;
            rowRemaining[r] = newRowRemaining;
            colRemaining[c] = newColRemaining;
            cageRemaining[cageIdx] = newCageRemaining;
            backtrack(cellIndex + 1);
            currentRowSums[r] -= value;
            currentColSums[c] -= value;
            currentCageSums[cageIdx] -= value;
            rowRemaining[r] = newRowRemaining + 1;
            colRemaining[c] = newColRemaining + 1;
            cageRemaining[cageIdx] = newCageRemaining + 1;
          }
        }
        
        // ÈÅ∏Êäû„Åó„Å™„ÅÑÂ†¥Âêà
        let canSkip = true;
        if (newRowRemaining === 0 && currentRowSums[r] !== rowSums[r]) canSkip = false;
        if (canSkip && newColRemaining === 0 && currentColSums[c] !== colSums[c]) canSkip = false;
        if (canSkip && newCageRemaining === 0 && currentCageSums[cageIdx] !== cageSums[cageIdx]) canSkip = false;
        if (canSkip) {
          rowRemaining[r] = newRowRemaining;
          colRemaining[c] = newColRemaining;
          cageRemaining[cageIdx] = newCageRemaining;
          backtrack(cellIndex + 1);
          rowRemaining[r] = newRowRemaining + 1;
          colRemaining[c] = newColRemaining + 1;
          cageRemaining[cageIdx] = newCageRemaining + 1;
        }
      }
      
      backtrack(0);
      return solutionCount;
    }

    // ========== „Éë„Ç∫„É´ÁîüÊàêÔºà„Ç∑„Éº„ÉâÂÄ§„ÅßÂõ∫ÂÆöÔºâ ==========
    function generatePuzzleWithSeed(difficulty, problemNumber) {
      const config = DIFFICULTIES[difficulty];
      const { size, selectRatio } = config;
      const baseSeed = (difficulty === 'easy' ? 0 : difficulty === 'medium' ? 100000 : 200000) + problemNumber;
      
      // Ë§áÊï∞„ÅÆ„Ç∑„Éº„Éâ„ÇíË©¶„ÅôÔºà‰∏ÄÊÑèËß£„ÅåË¶ã„Å§„Åã„Çã„Åæ„ÅßÔºâ
      for (let seedOffset = 0; seedOffset < 1000; seedOffset++) {
        const seed = baseSeed * 1000 + seedOffset;
        const random = mulberry32(seed);
        
        // Êï∞Â≠ó„ÇíÁîüÊàê
        const numbers = [];
        for (let r = 0; r < size; r++) {
          const row = [];
          for (let c = 0; c < size; c++) {
            row.push(Math.floor(random() * 9) + 1);
          }
          numbers.push(row);
        }
        
        // Ëß£Á≠î„Éë„Çø„Éº„É≥„ÇíÁîüÊàê
        const solution = [];
        for (let r = 0; r < size; r++) {
          const row = [];
          for (let c = 0; c < size; c++) {
            row.push(random() < selectRatio);
          }
          solution.push(row);
        }
        
        for (let r = 0; r < size; r++) {
          if (!solution[r].some(v => v)) {
            solution[r][Math.floor(random() * size)] = true;
          }
        }
        for (let c = 0; c < size; c++) {
          let has = false;
          for (let r = 0; r < size; r++) if (solution[r][c]) has = true;
          if (!has) solution[Math.floor(random() * size)][c] = true;
        }
        
        // „Ç±„Éº„Ç∏„ÇíÁîüÊàê
        const cages = generateCagesSeeded(size, random);
        const cagesWithColor = cages.map((cage, index) => ({
          cells: cage,
          color: PASTEL_COLORS[index % PASTEL_COLORS.length],
          id: index,
        }));
        
        const cellToCage = {};
        cagesWithColor.forEach((cage, cageIndex) => {
          cage.cells.forEach(cell => {
            cellToCage[`${cell.r},${cell.c}`] = cageIndex;
          });
        });
        
        cagesWithColor.forEach(cage => {
          const hasSelection = cage.cells.some(cell => solution[cell.r][cell.c]);
          if (!hasSelection && cage.cells.length > 0) {
            const randomCell = cage.cells[Math.floor(random() * cage.cells.length)];
            solution[randomCell.r][randomCell.c] = true;
          }
        });
        
        // ÂêàË®à„ÇíË®àÁÆó
        const rowSums = [];
        for (let r = 0; r < size; r++) {
          let sum = 0;
          for (let c = 0; c < size; c++) if (solution[r][c]) sum += numbers[r][c];
          rowSums.push(sum);
        }
        
        const colSums = [];
        for (let c = 0; c < size; c++) {
          let sum = 0;
          for (let r = 0; r < size; r++) if (solution[r][c]) sum += numbers[r][c];
          colSums.push(sum);
        }
        
        const cageSums = cagesWithColor.map(cage => 
          cage.cells.reduce((sum, cell) => solution[cell.r][cell.c] ? sum + numbers[cell.r][cell.c] : sum, 0)
        );
        
        // Ëß£„ÅÆ‰∏ÄÊÑèÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        const solutionCount = countSolutions(numbers, rowSums, colSums, cageSums, cellToCage, size, 2);
        
        if (solutionCount === 1) {
          return { size, numbers, solution, cages: cagesWithColor, cellToCage, rowSums, colSums, cageSums };
        }
      }
      
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºà„Åª„ÅºËµ∑„Åì„Çâ„Å™„ÅÑÔºâ
      console.warn('Fallback puzzle generation');
      return null;
    }

    // ========== „É°„Ç§„É≥„Ç¢„Éó„É™ ==========
    function App() {
      const [screen, setScreen] = useState('home');
      const [difficulty, setDifficulty] = useState('easy');
      const [problemNumber, setProblemNumber] = useState(1);
      const [progress, setProgress] = useState(loadProgress);
      const [lives, setLives] = useState(loadLives);
      const [puzzle, setPuzzle] = useState(null);
      const [cellStates, setCellStates] = useState({});
      const [mode, setMode] = useState('select');
      const [gameLives, setGameLives] = useState(GAME_LIVES);
      const [wrongCell, setWrongCell] = useState(null);
      const [showResult, setShowResult] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [timer, setTimer] = useState(0);
      const [mistakes, setMistakes] = useState(0);
      const timerRef = useRef(null);

      // „É©„Ç§„ÉïÂõûÂæ©„Çø„Ç§„Éû„Éº
      useEffect(() => {
        const interval = setInterval(() => {
          setLives(prev => {
            if (prev.current >= MAX_LIVES) return prev;
            const now = Date.now();
            const elapsed = now - prev.lastUpdate;
            if (elapsed >= LIFE_RECOVERY_MINUTES * 60 * 1000) {
              const newLives = Math.min(MAX_LIVES, prev.current + 1);
              const updated = { current: newLives, lastUpdate: now };
              saveLives(updated);
              return updated;
            }
            return prev;
          });
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      // „Ç≤„Éº„É†„Çø„Ç§„Éû„Éº
      useEffect(() => {
        if (screen === 'game' && puzzle && !showResult) {
          timerRef.current = setInterval(() => setTimer(t => t + 1), 1000);
        } else {
          clearInterval(timerRef.current);
        }
        return () => clearInterval(timerRef.current);
      }, [screen, puzzle, showResult]);

      const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      };

      const getNextRecoveryTime = () => {
        if (lives.current >= MAX_LIVES) return null;
        const elapsed = Date.now() - lives.lastUpdate;
        const remaining = LIFE_RECOVERY_MINUTES * 60 * 1000 - elapsed;
        if (remaining <= 0) return '0:00';
        const m = Math.floor(remaining / 60000);
        const s = Math.floor((remaining % 60000) / 1000);
        return `${m}:${s.toString().padStart(2, '0')}`;
      };

      const getTotalCleared = () => {
        let total = 0;
        Object.values(progress).forEach(diff => {
          total += Object.keys(diff).filter(k => diff[k]?.cleared).length;
        });
        return total;
      };

      const getDifficultyCleared = (diff) => {
        return Object.keys(progress[diff] || {}).filter(k => progress[diff][k]?.cleared).length;
      };

      const startGame = (diff, num) => {
        if (lives.current <= 0) {
          alert('„É©„Ç§„Éï„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂõûÂæ©„Çí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ');
          return;
        }
        
        setDifficulty(diff);
        setProblemNumber(num);
        setIsLoading(true);
        setScreen('game');
        setCellStates({});
        setMode('select');
        setGameLives(GAME_LIVES);
        setShowResult(null);
        setTimer(0);
        setMistakes(0);
        
        // „É©„Ç§„ÉïÊ∂àË≤ª
        const newLives = { current: lives.current - 1, lastUpdate: lives.current >= MAX_LIVES ? Date.now() : lives.lastUpdate };
        setLives(newLives);
        saveLives(newLives);
        
        setTimeout(() => {
          const newPuzzle = generatePuzzleWithSeed(diff, num);
          setPuzzle(newPuzzle);
          setIsLoading(false);
        }, 50);
      };

      const handleCellClick = useCallback((r, c) => {
        if (!puzzle || showResult) return;
        
        const key = `${r},${c}`;
        const currentState = cellStates[key];
        const isCorrectAnswer = puzzle.solution[r][c];
        
        if (currentState === 'selected' && isCorrectAnswer) return;
        if (currentState === 'erased' && !isCorrectAnswer) return;
        
        let isWrong = false;
        if (mode === 'select') {
          if (!isCorrectAnswer && currentState !== 'selected') isWrong = true;
        } else {
          if (isCorrectAnswer && currentState !== 'erased') isWrong = true;
        }
        
        if (isWrong) {
          setWrongCell(key);
          setTimeout(() => setWrongCell(null), 400);
          setMistakes(m => m + 1);
          setGameLives(prev => {
            const newLives = prev - 1;
            if (newLives <= 0) {
              setTimeout(() => setShowResult('gameover'), 300);
            }
            return newLives;
          });
          return;
        }
        
        setCellStates(prev => {
          let next;
          if (mode === 'select') {
            next = prev[key] === 'selected' ? undefined : 'selected';
          } else {
            next = prev[key] === 'erased' ? undefined : 'erased';
          }
          if (next === undefined) {
            const newStates = { ...prev };
            delete newStates[key];
            return newStates;
          }
          return { ...prev, [key]: next };
        });
      }, [mode, puzzle, cellStates, showResult]);

      // Ë®àÁÆóÁ≥ª„ÅÆuseMemo
      const calculateSums = useMemo(() => {
        if (!puzzle) return { rows: [], cols: [], cages: [] };
        const { size, numbers, cages } = puzzle;
        const rowSums = [], colSums = [];
        for (let r = 0; r < size; r++) {
          let sum = 0;
          for (let c = 0; c < size; c++) if (cellStates[`${r},${c}`] === 'selected') sum += numbers[r][c];
          rowSums.push(sum);
        }
        for (let c = 0; c < size; c++) {
          let sum = 0;
          for (let r = 0; r < size; r++) if (cellStates[`${r},${c}`] === 'selected') sum += numbers[r][c];
          colSums.push(sum);
        }
        const cageSums = cages.map(cage => cage.cells.reduce((sum, cell) => cellStates[`${cell.r},${cell.c}`] === 'selected' ? sum + numbers[cell.r][cell.c] : sum, 0));
        return { rows: rowSums, cols: colSums, cages: cageSums };
      }, [puzzle, cellStates]);

      const checkStatus = useMemo(() => {
        if (!puzzle) return { completed: false, rows: [], cols: [], cages: [], rowsFull: [], colsFull: [], cagesFull: [] };
        const { size, cages, rowSums, colSums, cageSums } = puzzle;
        
        const rowsFull = [], colsFull = [], cagesFull = [];
        for (let r = 0; r < size; r++) {
          let full = true;
          for (let c = 0; c < size; c++) {
            const s = cellStates[`${r},${c}`];
            if (s !== 'selected' && s !== 'erased') { full = false; break; }
          }
          rowsFull.push(full);
        }
        for (let c = 0; c < size; c++) {
          let full = true;
          for (let r = 0; r < size; r++) {
            const s = cellStates[`${r},${c}`];
            if (s !== 'selected' && s !== 'erased') { full = false; break; }
          }
          colsFull.push(full);
        }
        cages.forEach((cage, i) => {
          cagesFull.push(cage.cells.every(cell => {
            const s = cellStates[`${cell.r},${cell.c}`];
            return s === 'selected' || s === 'erased';
          }));
        });
        
        const rowsComplete = rowSums.map((t, i) => rowsFull[i] && calculateSums.rows[i] === t);
        const colsComplete = colSums.map((t, i) => colsFull[i] && calculateSums.cols[i] === t);
        const cagesComplete = cageSums.map((t, i) => cagesFull[i] && calculateSums.cages[i] === t);
        const completed = rowsComplete.every(Boolean) && colsComplete.every(Boolean) && cagesComplete.every(Boolean);
        
        const rowsOver = rowSums.map((t, i) => calculateSums.rows[i] > t);
        const colsOver = colSums.map((t, i) => calculateSums.cols[i] > t);
        const cagesOver = cageSums.map((t, i) => calculateSums.cages[i] > t);
        
        return { completed, rows: rowsComplete, cols: colsComplete, cages: cagesComplete, rowsOver, colsOver, cagesOver };
      }, [puzzle, cellStates, calculateSums]);

      // „ÇØ„É™„Ç¢Âà§ÂÆö
      useEffect(() => {
        if (checkStatus.completed && puzzle && !showResult) {
          const stars = mistakes === 0 ? 3 : mistakes === 1 ? 2 : 1;
          const newProgress = { ...progress };
          if (!newProgress[difficulty]) newProgress[difficulty] = {};
          const existing = newProgress[difficulty][problemNumber];
          if (!existing || !existing.cleared || existing.time > timer || existing.stars < stars) {
            newProgress[difficulty][problemNumber] = { cleared: true, time: timer, mistakes, stars };
            setProgress(newProgress);
            saveProgress(newProgress);
          }
          setShowResult('clear');
        }
      }, [checkStatus.completed]);

      const cellCageResolved = useMemo(() => {
        if (!puzzle) return {};
        const { size, cellToCage } = puzzle;
        const resolved = {};
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const key = `${r},${c}`;
            if (checkStatus.cages[cellToCage[key]]) resolved[key] = true;
          }
        }
        return resolved;
      }, [puzzle, checkStatus]);

      // ===== ÁîªÈù¢„É¨„É≥„ÉÄ„É™„É≥„Ç∞ =====
      
      // „Éõ„Éº„É†ÁîªÈù¢
      if (screen === 'home') {
        const recoveryTime = getNextRecoveryTime();
        return (
          <div className="app">
            <div className="home-screen">
              <div className="home-logo">üî¢</div>
              <h1 className="home-title">Number Sums</h1>
              <p className="home-subtitle">Êï∞Â≠ó„Éë„Ç∫„É´„Ç≤„Éº„É†</p>
              
              <button className="home-btn primary" onClick={() => {
                // Á∂ö„Åç„Åã„Çâ„Éó„É¨„Ç§
                for (const diff of ['easy', 'medium', 'hard']) {
                  const maxProb = DIFFICULTIES[diff].problems;
                  for (let i = 1; i <= maxProb; i++) {
                    if (!progress[diff]?.[i]?.cleared) {
                      startGame(diff, i);
                      return;
                    }
                  }
                }
                setScreen('select');
              }}>
                Á∂ö„Åç„Åã„Çâ„Éó„É¨„Ç§
              </button>
              
              <button className="home-btn secondary" onClick={() => setScreen('select')}>
                ÂïèÈ°å„ÇíÈÅ∏„Å∂
              </button>
              
              <div className="lives-display">
                <div className="lives-hearts">
                  {Array.from({ length: MAX_LIVES }).map((_, i) => (
                    <span key={i} style={{ opacity: i < lives.current ? 1 : 0.3 }}>‚ù§Ô∏è</span>
                  ))}
                </div>
                {recoveryTime ? (
                  <div className="lives-timer">Ê¨°„ÅÆÂõûÂæ©„Åæ„Åß: {recoveryTime}</div>
                ) : (
                  <div className="lives-full">„É©„Ç§„ÉïÊ∫Ä„Çø„É≥</div>
                )}
              </div>
              
              <div className="home-stats">
                <div className="stat-item">
                  <div className="stat-value">{getTotalCleared()}</div>
                  <div className="stat-label">„ÇØ„É™„Ç¢Êï∞</div>
                </div>
                <div className="stat-item">
                  <div className="stat-value">{getDifficultyCleared('easy')}/{DIFFICULTIES.easy.problems}</div>
                  <div className="stat-label">Á∞°Âçò</div>
                </div>
                <div className="stat-item">
                  <div className="stat-value">{getDifficultyCleared('medium')}/{DIFFICULTIES.medium.problems}</div>
                  <div className="stat-label">ÊôÆÈÄö</div>
                </div>
              </div>
            </div>
          </div>
        );
      }
      
      // ÂïèÈ°åÈÅ∏ÊäûÁîªÈù¢
      if (screen === 'select') {
        const config = DIFFICULTIES[difficulty];
        return (
          <div className="app">
            <div className="select-screen">
              <div className="select-header">
                <button className="back-btn" onClick={() => setScreen('home')}>‚Üê</button>
                <span className="select-title">ÂïèÈ°å„ÇíÈÅ∏„Å∂</span>
                <span style={{ fontSize: '20px' }}>
                  {Array.from({ length: lives.current }).map((_, i) => '‚ù§Ô∏è').join('')}
                  {Array.from({ length: MAX_LIVES - lives.current }).map((_, i) => 'üñ§').join('')}
                </span>
              </div>
              
              <div className="diff-tabs">
                {Object.entries(DIFFICULTIES).map(([key, cfg]) => (
                  <button
                    key={key}
                    className={`diff-tab ${difficulty === key ? 'active' : ''}`}
                    onClick={() => setDifficulty(key)}
                  >
                    {cfg.label}
                    <div className="count">{getDifficultyCleared(key)}/{cfg.problems}</div>
                  </button>
                ))}
              </div>
              
              <div className="problem-grid">
                {Array.from({ length: config.problems }).map((_, i) => {
                  const num = i + 1;
                  const data = progress[difficulty]?.[num];
                  const cleared = data?.cleared;
                  const stars = data?.stars || 0;
                  return (
                    <button
                      key={num}
                      className={`problem-btn ${cleared ? 'cleared' : ''}`}
                      onClick={() => startGame(difficulty, num)}
                    >
                      {num}
                      {cleared && <div className="stars">{'‚≠ê'.repeat(stars)}</div>}
                    </button>
                  );
                })}
              </div>
            </div>
          </div>
        );
      }
      
      // „Ç≤„Éº„É†ÁîªÈù¢
      if (screen === 'game') {
        if (isLoading || !puzzle) {
          return (
            <div className="app">
              <div className="game-screen">
                <div className="game-header">
                  <button className="back-btn" onClick={() => setScreen('select')}>‚Üê</button>
                  <span className="problem-number">No.{problemNumber}</span>
                  <span></span>
                </div>
                <div className="loading">
                  <div className="loading-spinner"></div>
                  <div className="loading-text">„Éë„Ç∫„É´„ÇíÁîüÊàê‰∏≠...</div>
                </div>
              </div>
            </div>
          );
        }
        
        const { size, numbers, cages, cellToCage, rowSums, colSums, cageSums } = puzzle;
        
        return (
          <div className="app">
            <div className="game-screen">
              <div className="game-header">
                <div className="game-info">
                  <button className="back-btn" onClick={() => setScreen('select')}>‚Üê</button>
                  <span className="problem-number">{DIFFICULTIES[difficulty].label} No.{problemNumber}</span>
                </div>
                <span className="game-timer">{formatTime(timer)}</span>
                <span className="game-lives">
                  {'‚ù§Ô∏è'.repeat(gameLives)}{'üñ§'.repeat(GAME_LIVES - gameLives)}
                </span>
              </div>
              
              <div className="game-main">
                {showResult && (
                  <div className="overlay">
                    <div className="modal">
                      {showResult === 'clear' ? (
                        <>
                          <div className="modal-emoji">üéâ</div>
                          <div className="modal-title">„ÇØ„É™„Ç¢ÔºÅ</div>
                          <div className="modal-stars">{'‚≠ê'.repeat(mistakes === 0 ? 3 : mistakes === 1 ? 2 : 1)}</div>
                          <div className="modal-stats">
                            <div className="modal-stat">
                              <div className="modal-stat-value">{formatTime(timer)}</div>
                              <div className="modal-stat-label">„Çø„Ç§„É†</div>
                            </div>
                            <div className="modal-stat">
                              <div className="modal-stat-value">{mistakes}</div>
                              <div className="modal-stat-label">„Éü„Çπ</div>
                            </div>
                          </div>
                          <button className="modal-btn" onClick={() => {
                            const next = problemNumber + 1;
                            if (next <= DIFFICULTIES[difficulty].problems) {
                              startGame(difficulty, next);
                            } else {
                              setScreen('select');
                            }
                          }}>
                            Ê¨°„ÅÆÂïèÈ°å„Å∏
                          </button>
                          <button className="modal-btn secondary" onClick={() => setScreen('select')}>
                            ÂïèÈ°åÈÅ∏Êäû„Å´Êàª„Çã
                          </button>
                        </>
                      ) : (
                        <>
                          <div className="modal-emoji">üíî</div>
                          <div className="modal-title gameover">„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</div>
                          <div className="modal-stats">
                            <div className="modal-stat">
                              <div className="modal-stat-value">{formatTime(timer)}</div>
                              <div className="modal-stat-label">„Çø„Ç§„É†</div>
                            </div>
                            <div className="modal-stat">
                              <div className="modal-stat-value">{mistakes}</div>
                              <div className="modal-stat-label">„Éü„Çπ</div>
                            </div>
                          </div>
                          <button className="modal-btn" onClick={() => startGame(difficulty, problemNumber)}>
                            „ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶
                          </button>
                          <button className="modal-btn secondary" onClick={() => setScreen('select')}>
                            ÂïèÈ°åÈÅ∏Êäû„Å´Êàª„Çã
                          </button>
                        </>
                      )}
                    </div>
                  </div>
                )}
                
                <div className="board-container">
                  <div className="col-sums">
                    {colSums.map((sum, c) => (
                      <div key={c} className={`sum-box ${checkStatus.cols[c] ? 'complete' : checkStatus.colsOver?.[c] ? 'over' : ''}`}>
                        {calculateSums.cols[c] > 0 && <span className="current">{calculateSums.cols[c]}</span>}
                        {sum}
                      </div>
                    ))}
                  </div>
                  <div className="board-row">
                    <div className="row-sums">
                      {rowSums.map((sum, r) => (
                        <div key={r} className={`row-sum-box ${checkStatus.rows[r] ? 'complete' : checkStatus.rowsOver?.[r] ? 'over' : ''}`}>
                          {calculateSums.rows[r] > 0 && <span className="current">{calculateSums.rows[r]}</span>}
                          {sum}
                        </div>
                      ))}
                    </div>
                    <div className="grid" style={{ gridTemplateColumns: `repeat(${size}, 1fr)` }}>
                      {Array.from({ length: size }).map((_, r) =>
                        Array.from({ length: size }).map((_, c) => {
                          const key = `${r},${c}`;
                          const state = cellStates[key];
                          const cageIndex = cellToCage[key];
                          const cage = cages[cageIndex];
                          const value = numbers[r][c];
                          const isCageResolved = cellCageResolved[key];
                          const isWrong = wrongCell === key;
                          const isTopLeft = cage.cells.every(cell => cell.r > r || (cell.r === r && cell.c >= c));
                          
                          return (
                            <div
                              key={key}
                              className={`cell ${state === 'selected' ? 'selected' : state === 'erased' ? 'erased' : ''} ${isCageResolved ? 'cage-resolved' : ''} ${isWrong ? 'wrong' : ''}`}
                              style={{
                                backgroundColor: isCageResolved ? '#fff' : cage.color,
                                borderRight: c === size - 1 ? 'none' : undefined,
                                borderBottom: r === size - 1 ? 'none' : undefined,
                              }}
                              onClick={() => handleCellClick(r, c)}
                            >
                              {isTopLeft && (
                                <span className={`cage-hint ${checkStatus.cages[cageIndex] ? 'complete' : checkStatus.cagesOver?.[cageIndex] ? 'over' : ''}`}>
                                  {cageSums[cageIndex]}
                                </span>
                              )}
                              <span className="number">{value}</span>
                            </div>
                          );
                        })
                      )}
                    </div>
                  </div>
                </div>
                
                <div className="controls">
                  <div className="mode-switch">
                    <button className={`mode-btn ${mode === 'select' ? 'active' : ''}`} onClick={() => setMode('select')}>
                      <span className="icon">‚≠ï</span>
                      <span className="label">ÈÅ∏Êäû</span>
                    </button>
                    <button className={`mode-btn ${mode === 'erase' ? 'active' : ''}`} onClick={() => setMode('erase')}>
                      <span className="icon">‚úï</span>
                      <span className="label">Ê∂àÂéª</span>
                    </button>
                  </div>
                  <div className="game-actions">
                    <button className="action-btn hint" onClick={() => alert('„Éí„É≥„ÉàÊ©üËÉΩ„ÅØÂ∫ÉÂëäË¶ñËÅ¥Âæå„Å´Âà©Áî®ÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åô')}>
                      üí° „Éí„É≥„Éà
                    </button>
                    <button className="action-btn reset" onClick={() => setCellStates({})}>
                      üîÑ „É™„Çª„ÉÉ„Éà
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }
      
      return null;
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
  
  <!-- Service WorkerÁôªÈå≤ -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            console.log('SW registered:', registration.scope);
          })
          .catch((error) => {
            console.log('SW registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>
